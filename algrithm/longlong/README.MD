# 2020-12-12

## 第二章， 算法基础

实现部分排序算法， 本想定义接口如下，做到接口通用且可被继承

```c++
class SortInterface {
 public:
  template<typename Type>
  virtual void sort(Type* start, Type* end, cmp c = std::less<Type>()) = 0;
};
```

但发现模板函数无法定义为虚函数，理由是模板函数在调用处确定类型，子类和父类会出现函数定义不一致问题。故使用int类型数据作为实现示例。
实现插入排序、合并排序、选择排序、冒泡排序，在数据量小的情况，冒泡排序 > 选择排序 > 插入排序 > 合并排序
主要原因，冒泡排序每轮检测是否需要继续排序，例如 1, 2, 3, 4这种排好序的数组只会遍历一次。合并排序由于存在数组拷贝，耗时相对较高，
TODO：优化合并排序耗时


## 第6章 堆与堆排序

实现堆数据结构及利用堆数据结构实现堆排序算法，
堆可理解为一颗完全二叉树，维持堆的性质应用下沉方法，插入一个元素是用上浮方法。
下沉：父节点同左孩子与右孩子比较找到最优，然后交换，循环进行，直到下标达到堆大小的一半，可想象成石头在水中下沉
上浮：当前节点同父节点比较，可想象成泡沫在水中上浮
学习到了模板泛化编程，声明与实现分离的写法
这里实现的堆排序算法在数据拷贝上耗时过大，主要原因是兼容了堆数据结构的通用性，如果单独做堆排序可减少大量耗时

## 第7章 快速排序

代码中实现使用Hoare partition，另外还有比较常见的Lomuto partition，比较容易理解，下面为其实现代码，但是在存在众数数量大是耗时较高，一般不作为库代码实现
```
size_t QuickSort::partition(int* start, int* end, cmp c) {
  int x = *(end - 1);
  int* i = start;
  int* j = start;
  for (; j < end - 2; ++j) {
    if (c(*j, x)) {
      swap(*i, *j);
      i++;
    }
  }
  swap(*i, *(end - 1));
  return i - start;
}
```